extern crate alloc;

<<<<<<< HEAD
#[cfg(feature = "postgres")]
mod tests {
    use super::*;
    use chrono::{TimeZone, Utc};
    use fuel_core::database::Database;
    use fuel_core::{
        model::fuel_block::FuelBlock,
        schema::scalars::HexString256,
        service::{Config, FuelService},
    };
    use fuel_gql_client::client::{FuelClient, PageDirection, PaginationRequest};
    use fuel_indexer::types::*;
    use fuel_storage::Storage;
    use fuel_tx::Receipt;
    use fuel_vm::{consts::*, prelude::*};
    use fuel_wasm_executor::{IndexExecutor, IndexerService, Manifest, SchemaManager};
    use fuels_rs::abi_encoder::ABIEncoder;
=======
include!("./test_data/abi_code.rs");

#[cfg(feature = "postgres")]
mod tests {
    use crate::{AnotherEvent, SomeEvent};
    use fuel_wasm_executor::{IndexExecutor, Manifest, SchemaManager};
    use fuels_core::abi_encoder::ABIEncoder;
>>>>>>> master

    const DATABASE_URL: &'static str = "postgres://postgres:my-secret@127.0.0.1:5432";
    const GRAPHQL_SCHEMA: &'static str = include_str!("./test_data/demo_schema.graphql");
    const MANIFEST: &'static str = include_str!("./test_data/demo_manifest.yaml");
    const WASM_BYTES: &'static [u8] = include_bytes!("./test_data/indexer_demo.wasm");

    fn create_log_transaction(rega: u16, regb: u16) -> fuel_tx::Transaction {
        let script = vec![
            Opcode::ADDI(0x10, REG_ZERO, rega),
            Opcode::ADDI(0x11, REG_ZERO, regb),
            Opcode::LOG(0x10, 0x11, REG_ZERO, REG_ZERO),
            Opcode::LOG(0x11, 0x12, REG_ZERO, REG_ZERO),
            Opcode::RET(REG_ONE),
        ]
        .iter()
        .copied()
        .collect::<Vec<u8>>();

        let gas_price = 0;
        let gas_limit = 1_000_000;
        let maturity = 0;
        fuel_tx::Transaction::script(
            gas_price,
            gas_limit,
            maturity,
            script,
            vec![],
            vec![],
            vec![],
            vec![],
        )
    }

<<<<<<< HEAD
    #[tokio::test]
    async fn test_blocks() {
        let srv = FuelService::new_node(Config::local_node()).await.unwrap();
        let client = FuelClient::from(srv.bound_address);
        // submit tx
        let _ = client.submit(&create_log_transaction(0xca, 0xba)).await;
        let _ = client.submit(&create_log_transaction(0xfa, 0x4f)).await;
        let _ = client.submit(&create_log_transaction(0x33, 0x11)).await;
        let mut indexer_service =
            IndexerService::new(srv.bound_address, DATABASE_URL.to_string()).unwrap();

        let manifest: Manifest = serde_yaml::from_str(MANIFEST).expect("Bad yaml file");
        indexer_service
            .add_indexer(manifest, GRAPHQL_SCHEMA, WASM_BYTES)
            .expect("Failed to initialize indexer");

        indexer_service.run().await;
=======
        let instance = IndexExecutor::new(DATABASE_URL.to_string(), manifest, WASM_BYTES)
            .expect("Error creating IndexExecutor");

        let mystruct = SomeEvent {
            id: 4,
            account: [0x43; 32],
        }
        .into_token();

        let myotherstruct = AnotherEvent {
            id: 4,
            hash: [0x21; 32],
            bar: false,
        }
        .into_token();

        let struct1 = ABIEncoder::new()
            .encode(&[mystruct])
            .expect("Failed encoding struct1");
        let struct2 = ABIEncoder::new()
            .encode(&[myotherstruct])
            .expect("Failed encoding struct1");

        instance
            .trigger_event("an_event_name", struct1)
            .expect("Indexing failed");
        instance
            .trigger_event("another_event_name", struct2)
            .expect("Indexing failed");
>>>>>>> master
    }
}
